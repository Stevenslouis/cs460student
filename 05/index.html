<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Boilerplate</title>
    <style>
        html,
        body {
            background-color: #000;
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden !important;
        }
    </style>

    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script src="https://mrdoob.github.io/stats.js/build/stats.min.js"></script>
    <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@latest/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@latest/examples/jsm/"
      }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { Pane } from 'https://cdn.jsdelivr.net/npm/tweakpane@4.0.5/dist/tweakpane.min.js';
        import { AnaglyphEffect } from 'three/addons/effects/AnaglyphEffect.js';
        import { VertexNormalsHelper } from 'three/addons/helpers/VertexNormalsHelper.js';

        let renderer, effect, controls, scene, camera, polyui;
        let pane = new Pane();
        let polyNormalsHelper;
        let stats = null;

        window.onload = function () {


            window['SCENE'] = {
                'anaglyph': false,
                'poly': null,
                'rotate_poly': false,
                'do_rotate_poly': function () {
                    window['SCENE']['rotate_poly'] = !window['SCENE']['rotate_poly'];
                },
                'rotate_blender': false,
                'do_rotate_blender': function () {
                    window['SCENE']['rotate_blender'] = !window['SCENE']['rotate_blender'];
                },
                'blender_old_material': null,
                'change_material': function () {
                    if (!window['SCENE']['blender_old_material']) {
                        window['SCENE']['blender_old_material'] = window['SCENE']['blender'].material.clone();
                        window['SCENE']['blender'].material = new THREE.MeshNormalMaterial();
                    } else {
                        window['SCENE']['blender'].material = window['SCENE']['blender_old_material'].clone();
                        window['SCENE']['blender_old_material'] = null;
                    }
                },
                'blender_helper': null
            };
            // Create scene

            scene = new THREE.Scene();

            // Setup camera
            const fov = 75;
            const aspect = window.innerWidth / window.innerHeight;
            const near = 0.1;
            const far = 800;
            camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
            camera.position.set(20, 0, 0);

            // Create renderer


            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);


            effect = new AnaglyphEffect(renderer);
            effect.setSize(window.innerWidth, window.innerHeight);

            document.body.appendChild(renderer.domElement);


            // stats.js widget
            stats = new Stats();
            document.body.appendChild(stats.domElement);


            // Setup lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);

            var sceneui = pane.addFolder({ title: 'Scene' });
            sceneui.addBinding(directionalLight.position, 'x', { min: -100, max: 100, label: 'Light X' });
            sceneui.addBinding(directionalLight.position, 'y', { min: -100, max: 100, label: 'Light Y' });

            sceneui.addBinding(directionalLight.position, 'z', { min: -100, max: 100, label: 'Light Z' });
            // sceneui.addBinding(directionalLight.intensity, '' ,{ min: -100, max: 100, label:  'Intensity' });

            sceneui.addBinding(window.SCENE, 'anaglyph');
            const loader = new GLTFLoader();


            loader.load('poly.glb', function (gltf) {
                var poly = gltf.scene.children[0];
                poly.scale.x = 10;
                poly.scale.y = 10;
                poly.scale.z = 10;
                poly.translateX(-10);
                scene.add(gltf.scene);

                window.SCENE.poly = poly;

                console.log('GLTF structure:', poly);





                createPolyUI()

            }, undefined, function (error) {
                console.error('Error loading GLTF model:', error);
            });


            loader.load('key_fob.glb', function (gltf) {
                var key_fob = gltf.scene.children[0];
                key_fob.scale.x = 10;
                key_fob.scale.y = 10;
                key_fob.scale.z = 10;


                scene.add(gltf.scene);

                window.SCENE.blender = key_fob;
                if (key_fob.geometry) {

                    key_fob.geometry.computeVertexNormals();
                    var helper = new VertexNormalsHelper(key_fob, 0.1, 'blue');
                    helper.visible = false;
                    scene.add(helper);
                    window.SCENE.blender_helper = helper
                    var blenderui = pane.addFolder({ title: 'Blender Mesh' });

                    blenderui.addBinding(helper, 'visible', { label: 'Show normals!' });
                    blenderui.addButton({ title: 'rotate!' }).on('click', () => {
                        window.SCENE.do_rotate_blender();
                    })
                    blenderui.addButton({ title: 'change materials!' }).on('click', () => {
                        window.SCENE.change_material();

                    })
                }
            }, undefined, function (error) {
                console.error('Error loading GLTF model:', error);
            });



            // Setup controls
            controls = new OrbitControls(camera, renderer.domElement);



            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);

            // Start animation loop
            animate();




        };

        function createPolyUI() {
            if (polyui) return;

            polyui = pane.addFolder({ title: 'PolyCam Mesh' });
            polyui.addBinding(window.SCENE.poly.material, 'wireframe');

            polyui.addButton({ title: 'rotate!' }).on('click', () => {
                window.SCENE.do_rotate_poly();
            })


        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }



        function animate() {
            requestAnimationFrame(animate);

            controls.update();

            if (window.SCENE.anaglyph) {
                effect.render(scene, camera);
            } else {
                renderer.render(scene, camera);
            }

            if (window.SCENE.poly) {
                if (window.SCENE.rotate_poly) {
                    const q = new THREE.Quaternion();
                    q.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI);
                    window.SCENE.poly.quaternion.slerp(q, 0.05);
                } else {
                    const identity = new THREE.Quaternion();
                    window.SCENE.poly.quaternion.slerp(identity, 0.05);
                }



                if (polyNormalsHelper) {
                    polyNormalsHelper.update();
                }
            }

            if (window.SCENE.blender) {
                if (window.SCENE.rotate_blender) {
                    const q = new THREE.Quaternion();
                    q.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI);
                    window.SCENE.blender.quaternion.slerp(q, 0.05);
                    window.SCENE.blender_helper.update();

                } else {
                    const identity = new THREE.Quaternion();
                    window.SCENE.blender.quaternion.slerp(identity, 0.05);
                    window.SCENE.blender_helper.update();
                }



                if (polyNormalsHelper) {
                    polyNormalsHelper.update();
                }
            }

            if (stats != null){
                stats.update();
            }




        }
    </script>
</head>

<body>
    <!-- Canvas will be inserted here by Three.js -->
</body>

</html>