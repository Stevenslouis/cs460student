<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Hallway</title>
    <style>
        html, body {
            background-color: #000;
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden !important;
        }
    </style>

    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script src="https://mrdoob.github.io/stats.js/build/stats.min.js"></script>
    <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@latest/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@latest/examples/jsm/"
      }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { Pane } from 'https://cdn.jsdelivr.net/npm/tweakpane@4.0.5/dist/tweakpane.min.js';

        let renderer, scene, camera;
        let pane = new Pane();
        let stats = null;

        const keys = {};
        let mouseDown = false;

        window.onload = function () {

            scene = new THREE.Scene();

            const fov = 75;
            const aspect = window.innerWidth / window.innerHeight;
            const near = 0.1;
            const far = 800;
            camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
            camera.position.set(0, 1.6, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            stats = new Stats();
            document.body.appendChild(stats.domElement);

            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);

            var sceneui = pane.addFolder({ title: 'Lighting Controls' });
            sceneui.addBinding(directionalLight.position, 'x', { min: -100, max: 100, label: 'Light X' });
            sceneui.addBinding(directionalLight.position, 'y', { min: -100, max: 100, label: 'Light Y' });
            sceneui.addBinding(directionalLight.position, 'z', { min: -100, max: 100, label: 'Light Z' });
            sceneui.addBinding(directionalLight, 'intensity', { min: 0, max: 3, step: 0.1, label: 'Intensity' });

            createHallway();

            setupControls();

            window.addEventListener('resize', onWindowResize, false);

            animate();

        };

        function createHallway() {
            const hallLength = 50;
            const hallWidth = 4;
            const hallHeight = 4;

            const floorGeometry = new THREE.PlaneGeometry(hallWidth, hallLength);
            const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = 0;
            scene.add(floor);

            const ceilingGeometry = new THREE.PlaneGeometry(hallWidth, hallLength);
            const ceilingMaterial = new THREE.MeshLambertMaterial({ color: 0x222222 });
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.y = hallHeight;
            scene.add(ceiling);

            const leftWallGeometry = new THREE.PlaneGeometry(hallLength, hallHeight);
            const leftWallMaterial = new THREE.MeshLambertMaterial({ color: 0x555555 });
            const leftWall = new THREE.Mesh(leftWallGeometry, leftWallMaterial);
            leftWall.rotation.y = Math.PI / 2;
            leftWall.position.set(-hallWidth/2, hallHeight/2, 0);
            scene.add(leftWall);

            const rightWallGeometry = new THREE.PlaneGeometry(hallLength, hallHeight);
            const rightWallMaterial = new THREE.MeshLambertMaterial({ color: 0x555555 });
            const rightWall = new THREE.Mesh(rightWallGeometry, rightWallMaterial);
            rightWall.rotation.y = -Math.PI / 2;
            rightWall.position.set(hallWidth/2, hallHeight/2, 0);
            scene.add(rightWall);

            const endWallGeometry = new THREE.PlaneGeometry(hallWidth, hallHeight);
            const endWallMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
            
            const endWall = new THREE.Mesh(endWallGeometry, endWallMaterial);
            endWall.position.set(0, hallHeight/2, -hallLength/2);
            scene.add(endWall);

            const startWall = new THREE.Mesh(endWallGeometry, endWallMaterial);
            startWall.position.set(0, hallHeight/2, hallLength/2);
            startWall.rotation.y = Math.PI;
            scene.add(startWall);

            // Create photo frames
            createPhotoFrames(hallWidth, hallHeight);
        }

        function createPhotoFrames(hallWidth, hallHeight) {
   

            for(let z = -20; z <= 20; z += 7) {
                createPhoto(-hallWidth/2 + 0.05, hallHeight/2 + 0.9, z, Math.PI/2);
                createPhoto(hallWidth/2 - 0.05, hallHeight/2 + 0.9, z, -Math.PI/2);
            }
        }

        function createPhoto(x, y, z, rotationY) {
            const frameWidth = Math.floor(Math.random() * 2) + 1;
            const frameHeight = Math.floor(Math.random() * 2) + 1;
            
     
            const frameGeometry = new THREE.BoxGeometry(frameWidth, frameHeight, 0.1);
            const frameMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x00FF00
            });
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            frame.position.set(x, y, z);
            frame.rotation.y = rotationY;
            scene.add(frame);

           
            const pictureGeometry = new THREE.PlaneGeometry(frameWidth - 0.2, frameHeight - 0.2);
            const pictureMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xFFD700
            });
            const picture = new THREE.Mesh(pictureGeometry, pictureMaterial);
            picture.position.set(x + (rotationY > 0 ? 0.06 : -0.06), y, z);
            picture.rotation.y = rotationY;
            scene.add(picture);
        }

        function setupControls() {
            window.addEventListener('keydown', (e) => {
                keys[e.key.toLowerCase()] = true;
            });
            
            window.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
            });
            
            // Simple mouse controls - track movement when mouse is down
            let mouseX = 0;
            let mouseY = 0;
            
            window.addEventListener('mousedown', (e) => {
                mouseDown = true;
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            
            window.addEventListener('mousemove', (e) => {
                if (!mouseDown) return;
                
                // Calculate how much mouse moved
                const deltaX = e.clientX - mouseX;
                const deltaY = e.clientY - mouseY;
                
                // Update camera rotation based on mouse movement
                camera.rotation.y -= deltaX * 0.005;
                camera.rotation.x -= deltaY * 0.005;
                
                // Limit vertical rotation
                camera.rotation.x = Math.max(-Math.PI/3, Math.min(Math.PI/3, camera.rotation.x));
                
                // Update mouse position for next frame
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            
            window.addEventListener('mouseup', () => {
                mouseDown = false;
            });
            
            // Prevent context menu
            window.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const moveSpeed = 0.1;
            
            if (keys['arrowup']) {
                camera.position.x -= Math.sin(camera.rotation.y) * moveSpeed;
                camera.position.z -= Math.cos(camera.rotation.y) * moveSpeed;
            }
            if (keys['arrowdown']) {
                camera.position.x += Math.sin(camera.rotation.y) * moveSpeed;
                camera.position.z += Math.cos(camera.rotation.y) * moveSpeed;
            }
            
            if (keys['arrowleft']) {
                camera.position.x -= Math.cos(camera.rotation.y) * moveSpeed;
                camera.position.z += Math.sin(camera.rotation.y) * moveSpeed;
            }
            if (keys['arrowright']) {
                camera.position.x += Math.cos(camera.rotation.y) * moveSpeed;
                camera.position.z -= Math.sin(camera.rotation.y) * moveSpeed;
            }
            
            camera.position.x = Math.max(-1.5, Math.min(1.5, camera.position.x));
            camera.position.z = Math.max(-24, Math.min(24, camera.position.z));

            renderer.render(scene, camera);

            if (stats != null) {
                stats.update();
            }
        }
    </script>
</head>
<body>
    <!-- Canvas will be inserted here by Three.js -->
</body>
</html>